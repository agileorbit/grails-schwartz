/* Copyright 2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.agileorbit.schwartz.util.jdbc

import com.agileorbit.schwartz.QuartzService
import groovy.transform.CompileStatic
import liquibase.Contexts
import liquibase.Liquibase
import liquibase.database.Database
import liquibase.database.DatabaseFactory
import liquibase.database.OfflineConnection
import liquibase.database.jvm.JdbcConnection
import liquibase.diff.DiffResult
import liquibase.diff.compare.CompareControl
import liquibase.diff.output.DiffOutputControl
import liquibase.diff.output.changelog.DiffToChangeLog
import liquibase.resource.FileSystemResourceAccessor
import liquibase.serializer.ChangeLogSerializerFactory
import liquibase.snapshot.EmptyDatabaseSnapshot
import liquibase.structure.core.Column
import liquibase.structure.core.DataType
import liquibase.structure.core.ForeignKey
import liquibase.structure.core.Index
import liquibase.structure.core.PrimaryKey
import liquibase.structure.core.Table

import javax.sql.DataSource
import java.sql.Connection

/**
 * Helper class for CreateJdbcTablesChangelogCommand.
 *
 * Creates in-memory Liquibase model objects and builds a changelog from those
 * in Groovy or XML format (or any format supported by Liquibase). Will
 * optionally generate the resulting SQL from the changelog.
 *
 * @author <a href='mailto:burt@agileorbit.com'>Burt Beckwith</a>
 */
@CompileStatic
class ChangelogGenerator extends AbstractGenerator {

	final DataSource dataSource

	ChangelogGenerator(QuartzService quartzService, DataSource dataSource) {
		super(quartzService)
		this.dataSource = dataSource
	}

	/**
	 * Generate a Liquibase changelog and return the contents, optionally
	 * generating SQL from the changelog if the filetype is 'sql'.
	 *
	 * @param fileType the extension of the file the contents will be written to, e.g. 'groovy', 'xml', yaml'
	 * @return the changelog or SQL
	 */
	String generate(String fileType = 'groovy') {

		Class<? extends Database> dbClass = findDatabaseClass()
		if (!dbClass) {
			throw new IllegalStateException('Unable to determine the Liquibase database type from the DataSource')
		}

		String prefix = tableNamePrefix()

		Map<String, Table> tables = [:]

		DiffResult diff = new DiffResult(
				new EmptyDatabaseSnapshot(dbClass.newInstance()),
				new EmptyDatabaseSnapshot(dbClass.newInstance()),
				CompareControl.STANDARD)

		for (TableData tableData in data) {
			Table table = new Table(name: prefix + tableData.name)
			tables[table.name] = table
			diff.addMissingObject table

			table.primaryKey = new PrimaryKey().setName('PRIMARY').setTable(table)
			diff.addMissingObject table.primaryKey
			for (ColumnData col in tableData.pk) {
				Column column = addVarchar(table, col.name, col.length, false)
				table.primaryKey.addColumn(table.primaryKey.columns.size(), column)
			}

			for (ColumnData col in tableData.columns) {
				switch (col.type) {
					case Type.BIGINT:
					case Type.BLOB:
					case Type.BOOLEAN:
					case Type.INTEGER:
					case Type.SMALLINT: addSimple  table, col.type, col.name, col.nullable; break
					case Type.DECIMAL:  addDecimal table, col.name, col.precision, col.scale, col.nullable; break
					case Type.STRING:   addVarchar table, col.name, col.length, col.nullable; break
				}
			}

			if (tableData.fk) {
				Table otherTable = tables[prefix + tableData.fk]
				ForeignKey fk = new ForeignKey()
						.setName('FK_' + (table.name - prefix) + '_' + (otherTable.name - prefix))
						.setForeignKeyTable(table).setPrimaryKeyTable(otherTable)
				for (Column c in otherTable.primaryKey.columns) {
					fk.addPrimaryKeyColumn c
					fk.addForeignKeyColumn table.getColumn(c.name)
				}
				table.outgoingForeignKeys << fk
				diff.addMissingObject fk
			}

			for (IndexData indexData in tableData.indexes) {
				Index index = new Index().setName(indexData.name).setTable(table)
				index.table.indexes << index
				for (columnName in indexData.columnNames) {
					index.addColumn index.table.getColumn(columnName)
				}
				assert index.columns.size() == indexData.columnNames.size()
				diff.addMissingObject index
			}
		}

		DiffToChangeLog changeLogWriter = new DiffToChangeLog(diff, new DiffOutputControl(false, false, false))
		changeLogWriter.changeSetAuthor = 'Generated by the Schwartz plugin'

		boolean sql = false
		if (fileType == 'sql') {
			fileType = 'xml'
			sql = true
		}

		ByteArrayOutputStream baos = new ByteArrayOutputStream()
		changeLogWriter.print(new PrintStream(baos),
				ChangeLogSerializerFactory.instance.getSerializer(fileType))

		String changeLogContents = new String(baos.toByteArray())
		if (sql) {
			generateSql changeLogContents, dbClass
		}
		else {
			changeLogContents
		}
	}

	protected String generateSql(String changelogXml, Class<? extends Database> dbClass) {
		File tempFile = File.createTempFile('schwartz', '.xml')
		tempFile.deleteOnExit()
		tempFile.text = changelogXml

		Database database = dbClass.newInstance()
		File csvFile = new File(System.getProperty('java.io.tmpdir'), UUID.randomUUID().toString().replaceAll('-', '') + '.csv')
		csvFile.deleteOnExit()
		database.connection = new OfflineConnection('offline:' + database.shortName +
				'?changeLogFile=' + csvFile.absolutePath, null)

		Liquibase liquibase = new Liquibase(tempFile.name,
				new FileSystemResourceAccessor(tempFile.parentFile.absolutePath), database)

		Writer sw = new StringWriter()
		liquibase.update((Contexts) null, sw)
		sw.toString()
	}

	protected Column addVarchar(Table table, String name, Integer length, boolean nullable) {
		newColumn table, Type.STRING, name, nullable, length, null, null
	}

	protected Column addDecimal(Table table, String name, Integer precision, Integer scale, boolean nullable) {
		newColumn table, Type.DECIMAL, name, nullable, null, precision, scale
	}

	protected Column addSimple(Table table, Type type, String name, boolean nullable) {
		newColumn table, type, name, nullable, null, null, null
	}

	protected Column newColumn(Table table, Type type, String name, boolean nullable,
	                           Integer length, Integer precision, Integer scale) {
		DataType datatype = new DataType(typeName: type.name().toLowerCase())
		if (type == Type.STRING) {
			datatype.columnSize = length
		}
		else if (type == Type.DECIMAL) {
			datatype.decimalDigits = precision
			datatype.radix = scale
		}

		Column column = new Column().setName(name).setNullable(nullable).setRelation(table).setType(datatype)
		table.columns << column
		column
	}

	protected Class<? extends Database> findDatabaseClass() {
		Connection connection
		try {
			connection = dataSource.connection
			JdbcConnection jc = new JdbcConnection(connection)
			for (Database db in DatabaseFactory.instance.implementedDatabases) {
				if (db.isCorrectDatabaseImplementation(jc)) {
					return db.getClass() as Class
				}
			}
		}
		finally {
			try { connection?.close() }
			catch (ignored) {}
		}
	}
}
